<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spatialgineers Visualizer</title>
  <!-- Tailwind CSS for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      overflow: hidden;
    }
    #canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }

    /* Branding watermark styles: bottom-left, always visible */
    #branding {
      position: absolute;
      bottom: 8px;
      left: 8px;
      z-index: 20;
      opacity: 0.6;
      pointer-events: none;
    }
    /* hide file inputs but keep label clickable */
    input[type=file] {
      display: none;
    }
    .panel {
      z-index: 10;
    }
  </style>
</head>
<body class="bg-black text-white">
  <canvas id="canvas"></canvas>
  <!-- Control panel -->
  <div id="panel" class="panel absolute top-3 right-3 w-[min(92vw,380px)] max-h-[calc(100vh-1.5rem)] rounded-2xl border border-white/10 bg-black/70 text-white shadow-xl overflow-y-auto p-4 space-y-3">
    <div class="flex justify-between items-center pb-2 border-b border-white/20">
      <h2 class="text-lg font-semibold">Spatialgineers Visualizer</h2>
      <button id="hidePanel" class="text-sm px-2 py-1 bg-white/20 hover:bg-white/30 rounded">Hide</button>
    </div>
    <!-- Shape & Mode selectors -->
    <div class="grid grid-cols-2 gap-2">
      <div>
        <label class="block text-xs mb-1">Shape</label>
        <select id="shapeSelect" class="w-full p-1 bg-gray-800 border border-gray-700 rounded">
          <option value="circle">Circle</option>
          <option value="square">Square</option>
          <option value="line">Line</option>
          <option value="image">Image</option>
          <option value="bars">Bars</option>
        </select>
      </div>
      <div>
        <label class="block text-xs mb-1">Behaviour</label>
        <select id="behaviorSelect" class="w-full p-1 bg-gray-800 border border-gray-700 rounded">
          <option value="random">Random</option>
          <option value="fromCenter">From Center</option>
          <option value="fromBottom">From Bottom</option>
          <option value="fromTop">From Top</option>
          <option value="fromLeft">From Left</option>
          <option value="fromRight">From Right</option>
          <option value="spiral">Spiral</option>
      <option value="path">Path</option>
      <option value="galaxy">Galaxy</option>
        </select>
      </div>
    </div>
    <!-- Colors -->
    <div>
      <label class="block text-xs mb-1">Colors</label>
      <div class="flex space-x-2">
        <input type="color" id="c1" value="#3a0d00" class="w-6 h-6 border-none p-0">
        <input type="color" id="c2" value="#fd6a00" class="w-6 h-6 border-none p-0">
        <input type="color" id="c3" value="#ffd26a" class="w-6 h-6 border-none p-0">
        <input type="color" id="c4" value="#000000" class="w-6 h-6 border-none p-0">
      </div>
    </div>
    <!-- Image upload for particles -->
    <div id="imageUploadRow" class="hidden">
      <label class="block text-xs mb-1">Particle Images</label>
      <label class="w-full py-1 px-3 bg-gray-700 hover:bg-gray-600 rounded cursor-pointer text-xs">Choose images
        <input type="file" id="particleImages" multiple accept="image/*">
      </label>
    </div>
    <!-- Background upload -->
    <div>
      <label class="block text-xs mb-1">Background Image</label>
      <label class="w-full py-1 px-3 bg-gray-700 hover:bg-gray-600 rounded cursor-pointer text-xs">Choose background
        <input type="file" id="backgroundImage" accept="image/*">
      </label>
    </div>
    <!-- Sliders and toggles -->
    <div class="space-y-2">
      <div class="flex items-center justify-between">
        <label class="text-xs">Count</label>
        <input type="range" id="countSlider" min="10" max="500" value="200" class="w-40">
      </div>
      <div class="flex items-center justify-between">
        <label class="text-xs">Size</label>
        <input type="range" id="sizeSlider" min="1" max="50" value="8" class="w-40">
      </div>
      <div class="flex items-center justify-between">
        <label class="text-xs">Speed</label>
        <input type="range" id="speedSlider" min="0.1" max="5" value="1" step="0.1" class="w-40">
      </div>
      <div class="flex items-center justify-between">
        <label class="text-xs">Turbulence</label>
        <input type="range" id="turbSlider" min="0" max="2" value="1" step="0.1" class="w-40">
      </div>
      <div class="flex items-center justify-between">
        <label class="text-xs">Width Factor</label>
        <input type="range" id="widthSlider" min="0.1" max="3" value="1" step="0.1" class="w-40">
      </div>
      <div class="flex items-center justify-between">
        <label class="text-xs">Height Factor</label>
        <input type="range" id="heightSlider" min="0.1" max="3" value="1" step="0.1" class="w-40">
      </div>
      <div class="flex items-center justify-between">
        <label class="text-xs">Glow</label>
        <input type="range" id="glowSlider" min="0" max="3" value="1" step="0.1" class="w-40">
      </div>
      <div class="flex items-center justify-between">
        <label class="text-xs">Mic Reactive</label>
        <input type="checkbox" id="micToggle" checked>
      </div>
      <div class="flex items-center justify-between">
        <label class="text-xs">Pointer Wind</label>
        <input type="checkbox" id="windToggle">
      </div>
      <div class="flex items-center justify-between">
        <label class="text-xs">Auto Drift</label>
        <input type="checkbox" id="driftToggle" checked>
      </div>
    </div>
    <!-- Path Drawing Controls -->
    <div id="pathControls" class="hidden space-y-2 pt-2 border-t border-white/20">
      <!-- When behaviour is 'path', clicking on the canvas toggles drawing on/off. The buttons below provide an explicit clear/reset control. -->
      <button id="clearPath" class="w-full py-1 bg-red-600 hover:bg-red-500 rounded text-sm">Clear Path</button>
    </div>
    <!-- Randomize & Share -->
    <div class="flex space-x-2 pt-2 border-t border-white/20">
      <button id="randomizeBtn" class="flex-1 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm">Randomize</button>
      <button id="shareBtn" class="flex-1 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm">Share</button>
      <button id="embedBtn" class="flex-1 py-1 bg-gray-600 hover:bg-gray-500 rounded text-sm">Embed</button>
    </div>
    <!-- Show panel button hidden by default -->
    <button id="showPanel" class="hidden absolute top-3 right-3 py-1 px-3 bg-white/20 hover:bg-white/30 rounded text-sm">Show</button>

  <!-- Branding / watermark -->
  <div id="branding" class="absolute bottom-2 left-2 text-xs text-white/60 pointer-events-none select-none">Spatialgineers Visualizer</div>
  </div>
  <script>
  // Canvas and context
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let width = canvas.width = window.innerWidth;
  let height = canvas.height = window.innerHeight;
  window.addEventListener('resize', () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
  });

  // Settings object
  const settings = {
    shape: 'circle',
    behavior: 'random',
    colors: ['#3a0d00', '#fd6a00', '#ffd26a', '#000000'],
    count: 200,
    size: 8,
    speed: 1,
    turb: 1,
    widthFactor: 1,
    heightFactor: 1,
    glow: 1,
    micReactive: true,
    pointerWind: false,
    drift: true,
    images: [],
    background: null,
    particles: [],
    pathPoints: [],
    drawing: false,
    micLevel: 0,
    audioCtx: null,
    analyser: null,
    micData: null,
    windX: 0
    ,rotationSpeed: 0.1
  };

  // UI elements
  const shapeSelect = document.getElementById('shapeSelect');
  const behaviorSelect = document.getElementById('behaviorSelect');
  const c1 = document.getElementById('c1');
  const c2 = document.getElementById('c2');
  const c3 = document.getElementById('c3');
  const c4 = document.getElementById('c4');
  const countSlider = document.getElementById('countSlider');
  const sizeSlider = document.getElementById('sizeSlider');
  const speedSlider = document.getElementById('speedSlider');
  const turbSlider = document.getElementById('turbSlider');
  const widthSlider = document.getElementById('widthSlider');
  const heightSlider = document.getElementById('heightSlider');
  const glowSlider = document.getElementById('glowSlider');
  const micToggle = document.getElementById('micToggle');
  const windToggle = document.getElementById('windToggle');
  const driftToggle = document.getElementById('driftToggle');
  const particleImagesInput = document.getElementById('particleImages');
  const backgroundImageInput = document.getElementById('backgroundImage');
  const imageUploadRow = document.getElementById('imageUploadRow');
  const pathControls = document.getElementById('pathControls');
  const startDrawingBtn = document.getElementById('startDrawing');
  const clearPathBtn = document.getElementById('clearPath');
  const randomizeBtn = document.getElementById('randomizeBtn');
  const shareBtn = document.getElementById('shareBtn');
  const embedBtn = document.getElementById('embedBtn');
  const hidePanelBtn = document.getElementById('hidePanel');
  const showPanelBtn = document.getElementById('showPanel');
  const panel = document.getElementById('panel');
  const branding = document.getElementById('branding');

  // Setup mic
  async function initMic() {
    try {
      settings.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      settings.analyser = settings.audioCtx.createAnalyser();
      settings.analyser.fftSize = 512;
      const source = settings.audioCtx.createMediaStreamSource(stream);
      source.connect(settings.analyser);
      settings.micData = new Uint8Array(settings.analyser.frequencyBinCount);
      console.log('Mic initialized');
    } catch (err) {
      console.log('Mic init failed', err);
      settings.analyser = null;
    }
  }

  // Get mic level
  function getMicLevel() {
    if (!settings.analyser || !settings.micReactive) return 0;
    settings.analyser.getByteFrequencyData(settings.micData);
    let sum = 0;
    const len = Math.min(64, settings.micData.length);
    for (let i = 0; i < len; i++) sum += settings.micData[i];
    // compute normalized average
    const level = (sum / len) / 255;
    // amplify strongly so mic visibly affects visuals; clamp between 0 and 1
    return Math.min(level * 20, 1);
  }

  // Particle class
  class Particle {
    constructor() {
      this.reset();
    }
    reset() {
      // spawn position based on behavior
      switch (settings.behavior) {
        case 'fromCenter':
          this.x = width / 2;
          this.y = height / 2;
          break;
        case 'fromBottom':
          this.x = Math.random() * width;
          this.y = height + settings.size;
          break;
        case 'fromTop':
          this.x = Math.random() * width;
          this.y = -settings.size;
          break;
        case 'fromLeft':
          this.x = -settings.size;
          this.y = Math.random() * height;
          break;
        case 'fromRight':
          this.x = width + settings.size;
          this.y = Math.random() * height;
          break;
        case 'spiral':
          // assign radius and angle for spiral motion. Each particle orbits around the center.
          this.radius = Math.random() * Math.min(width, height) * 0.4;
          this.angle = Math.random() * Math.PI * 2;
          this.x = width / 2 + Math.cos(this.angle) * this.radius;
          this.y = height / 2 + Math.sin(this.angle) * this.radius;
          // give each particle its own rotation offset
          this.rot = Math.random() * Math.PI * 2;
          break;
        case 'galaxy':
        // galaxy behaviour: like spiral but slower and larger radius distribution
          this.radius = Math.random() * Math.min(width, height) * 0.8;
          this.angle = Math.random() * Math.PI * 2;
          this.x = width / 2 + Math.cos(this.angle) * this.radius;
          this.y = height / 2 + Math.sin(this.angle) * this.radius;
          this.rot = Math.random() * Math.PI * 2;
          break;
        default: // random
          this.x = Math.random() * width;
          this.y = Math.random() * height;
      }
      // velocity
      const angle = Math.random() * Math.PI * 2;
      const speed = settings.speed * (0.5 + Math.random());
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed;
      // override velocities for directional behaviours
      switch (settings.behavior) {
        case 'fromLeft':
          this.vx = Math.abs(this.vx) + settings.speed;
          this.vy = (Math.random() - 0.5) * settings.speed;
          break;
        case 'fromRight':
          this.vx = -Math.abs(this.vx) - settings.speed;
          this.vy = (Math.random() - 0.5) * settings.speed;
          break;
      }
      // shape-specific properties
      this.size = settings.size * (0.5 + Math.random());
      this.col = randomColor();
      this.img = null;
      if (settings.shape === 'image' && settings.images.length > 0) {
        this.img = settings.images[Math.floor(Math.random() * settings.images.length)];
      }
      // Path parameter for path behaviour
      this.t = Math.random();
    }
    update(dt) {
      // mic influences many aspects of movement
      const micLevel = settings.micReactive ? settings.micLevel : 0;
      // bars handled elsewhere
      if (settings.shape === 'bars') return;
      // Path behaviour: follow drawn path based on param t. Toggle using clicks on canvas.
      if (settings.behavior === 'path' && settings.pathPoints.length > 1) {
        this.t += dt * settings.speed * 0.1 * (1 + micLevel);
        this.t %= 1;
        const pos = pointOnPath(settings.pathPoints, this.t);
        this.x = pos.x;
        this.y = pos.y;
        return;
      }
      // Spiral behaviour: orbit around center with its own rotation
      if (settings.behavior === 'spiral') {
        this.angle += dt * settings.speed * settings.rotationSpeed * (1 + micLevel * 2);
        // slight radial jitter based on turbulence
        this.radius += (Math.random() - 0.5) * settings.turb * 0.1;
        this.x = width / 2 + Math.cos(this.angle) * this.radius;
        this.y = height / 2 + Math.sin(this.angle) * this.radius;
        this.rot += dt * settings.speed * 0.5 * (1 + micLevel);
        return;
      }
      // Galaxy behaviour: swirl like spiral but slower and larger
      if (settings.behavior === 'galaxy') {
        // extra slow rotation for galaxy; large radius variations
        this.angle += dt * settings.speed * 0.01 * (1 + micLevel);
        this.radius += (Math.random() - 0.5) * settings.turb * 0.05;
        this.x = width / 2 + Math.cos(this.ngle) * this.radius;
        this.y = height / 2 + Math.sin(this.angle) * this.radius;
        this.rot += dt * settings.speed * 0.2 * (1 + micLevel);
        return;
      }
      // Default behaviours (random, from edges, etc.): apply turbulence, pointer wind, drift, scaling and mic
              // settings.windX *= 0.94;
              this.vx += (Math.random() - 0.5) * settings.turb * (1 + micLevel) * 0.1;
              this.vy += (Math.random() - 0.5) * settings.turb * (1 + micLevel) * 0.1;
         if (settings.pointerWind) {
            // stronger wind effect: apply windX with higher influence
            this.vx += settings.windX * 2.0;
            settings.windX *= 0.94;
        }
      if (settings.drift) {
        const t = performance.now();
        this.vx += Math.sin(t / 4000) * 0.02;
        this.vy += Math.cos(t / 4000) * 0.02;
      }
      // apply width and height scaling factors and mic influence
      // apply width and height scaling factors and mic influence (more responsive)
      this.x += this.vx * settings.widthFactor * (1 + micLevel * 3);
      this.y += this.vy * settings.heightFactor * (1 + micLevel * 3);
      // Wrap or reset
      if (this.x < -50 || this.x > width + 50 || this.y < -50 || this.y > height + 50) {
        this.reset();
      }
    }
    draw() {
      const micLevel = settings.micReactive ? settings.micLevel : 0;
      // mix color with its inverted version based on mic level; stronger inversion on beats
      const inv = invertColor(this.col);
      // linearly interpolate each channel
      const origRgb = hexToRgb(this.col);
      const invRgb = hexToRgb(inv);
      const mixedRgb = origRgb.map((v,i) => v * (1 - micLevel) + invRgb[i] * micLevel);
      let col = rgbToHex(mixedRgb);
      ctx.save();
      ctx.globalAlpha = 0.8 + micLevel * 0.2;
      if (settings.shape === 'circle') {
        // incorporate glow factor into radius
        const rad = this.size * settings.glow * (1 + micLevel);
        const grd = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, rad);
        grd.addColorStop(0, col);
        grd.addColorStop(1, 'transparent');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(this.x, this.y, rad, 0, Math.PI * 2);
        ctx.fill();
      } else if (settings.shape === 'square') {
        const s = this.size * settings.glow * (1 + micLevel);
        ctx.fillStyle = col;
        ctx.save();
        // rotate square around its centre when spiral or galaxy behaviour
        ctx.translate(this.x, this.y);
        ctx.rotate(settings.behavior === 'spiral' || settings.behavior === 'galaxy' ? this.rot : 0);
        ctx.fillRect(-s / 2, -s / 2, s, s);
        ctx.restore();
      } else if (settings.shape === 'line') {
        const len = this.size * 4 * settings.glow * (1 + micLevel);
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        ctx.save();
        ctx.translate(this.x, this.y);
        // rotate line like a spinner when spiral/galaxy
        ctx.rotate(settings.behavior === 'spiral' || settings.behavior === 'galaxy' ? this.rot : 0);
        ctx.beginPath();
        ctx.moveTo(-len / 2, 0);
        ctx.lineTo(len / 2, 0);
        ctx.stroke();
        ctx.restore();
      } else if (settings.shape === 'image' && this.img) {
        const s = this.size * 3 * settings.glow * (1 + micLevel);
        ctx.save();
        ctx.translate(this.x, this.y);
        // rotate image when spiral/galaxy or random spin
        const rotAngle = settings.behavior === 'spiral' || settings.behavior === 'galaxy' ? this.rot : (this.vx + this.vy) * 0.05;
        ctx.rotate(rotAngle);
        ctx.drawImage(this.img, -s / 2, -s / 2, s, s);
        ctx.restore();
      }
      ctx.restore();
    }
  }

  // Helper to get a point on path
  function pointOnPath(points, t) {
    // simple linear interpolation between points
    const total = points.length;
    const f = t * (total - 1);
    const i = Math.floor(f);
    const frac = f - i;
    const p1 = points[i];
    const p2 = points[(i + 1) % total];
    return {
      x: p1.x + (p2.x - p1.x) * frac,
      y: p1.y + (p2.y - p1.y) * frac,
    };
  }

  // Random color from gradient
  function randomColor() {
    const t = Math.random();
    const [cA, cB, cC, cD] = settings.colors.map(hexToRgb);
    function lerp(a,b,t){ return a + (b - a) * t; }
    let col;
    if (t < 0.33) {
      col = cA.map((v, i) => lerp(v, cB[i], t / 0.33));
    } else if (t < 0.66) {
      col = cB.map((v, i) => lerp(v, cC[i], (t - 0.33) / 0.33));
    } else {
      col = cC.map((v, i) => lerp(v, cD[i], (t - 0.66) / 0.34));
    }
    return rgbToHex(col);
  }

  function invertColor(hex) {
    const rgb = hexToRgb(hex);
    const inv = rgb.map(v => 1 - v);
    return rgbToHex(inv);
  }
  function hexToRgb(hex) {
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16)/255;
    const g = parseInt(h.substring(2,4),16)/255;
    const b = parseInt(h.substring(4,6),16)/255;
    return [r,g,b];
  }
  function rgbToHex(rgb) {
    return '#' + rgb.map(v => {
      const h = Math.round(v*255).toString(16).padStart(2,'0');
      return h;
    }).join('');
  }

  // Initialize particles
  function initParticles() {
    settings.particles = [];
    for (let i = 0; i < settings.count; i++) {
      settings.particles.push(new Particle());
    }
  }

  function drawBackground() {
    if (settings.background) {
      ctx.drawImage(settings.background, 0, 0, width, height);
    } else {
      ctx.fillStyle = settings.colors[3] || '#000000';
      ctx.fillRect(0, 0, width, height);
    }
  }

  function drawBars() {
    // bars: draws vertical bars across width using mic level and colors
    // Draw responsive bars. Use analyser data when available.
    const n = Math.min(settings.count, 64);
    const barWidth = width / n;
    for (let i = 0; i < n; i++) {
      let amplitude = 0;
      if (settings.analyser && settings.micData) {
        // sample from frequency data at intervals
        const index = Math.floor(i / n * settings.micData.length);
        amplitude = settings.micData[index] / 255;
      } else {
        // fall back to global mic level with some randomness
        amplitude = settings.micLevel + Math.random() * 0.3;
      }
      // ensure amplitude is between 0 and 1
      amplitude = Math.max(0, Math.min(amplitude, 1));
      // compute bar height using amplitude, height factor and turbulence to add variation
      const hMult = 0.5 + Math.random() * 0.5;
      const barHeight = Math.max(4, amplitude * height * settings.heightFactor * 1.5 * hMult);
      const x = i * barWidth;
      const y = height - barHeight;
      const col = randomColor();
      ctx.fillStyle = col;
      ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barHeight);
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    // Update mic level
    settings.micLevel = getMicLevel();
    drawBackground();
    if (settings.shape === 'bars') {
      drawBars();
    } else {
      // update and draw particles
      const now = performance.now();
      const dt = 0.016;
      settings.particles.forEach(p => {
        p.update(dt);
        p.draw();
      });
    }
  }

  // Event handlers
  shapeSelect.addEventListener('change', (e) => {
    settings.shape = e.target.value;
    // show image upload row only for image shape
    imageUploadRow.classList.toggle('hidden', settings.shape !== 'image');
    // show path controls only for path behaviour
    pathControls.classList.toggle('hidden', settings.behavior !== 'path');
    if (settings.shape === 'bars') {
      behaviorSelect.value = 'random';
      behaviorSelect.disabled = true;
    } else {
      behaviorSelect.disabled = false;
    }
    initParticles();
  });
  behaviorSelect.addEventListener('change', (e) => {
    settings.behavior = e.target.value;
    pathControls.classList.toggle('hidden', settings.behavior !== 'path');
    initParticles();
  });
  [c1,c2,c3,c4].forEach((input, idx) => {
    input.addEventListener('input', () => {
      settings.colors[idx] = input.value;
    });
  });
  countSlider.addEventListener('input', () => {
    settings.count = parseInt(countSlider.value, 10);
    initParticles();
  });
  sizeSlider.addEventListener('input', () => {
    settings.size = parseFloat(sizeSlider.value);
  });
  speedSlider.addEventListener('input', () => {
    settings.speed = parseFloat(speedSlider.value);
  });
  turbSlider.addEventListener('input', () => {
    settings.turb = parseFloat(turbSlider.value);
  });
  widthSlider.addEventListener('input', () => {
    settings.widthFactor = parseFloat(widthSlider.value);
  });
  heightSlider.addEventListener('input', () => {
    settings.heightFactor = parseFloat(heightSlider.value);
  });
  glowSlider.addEventListener('input', () => {
    settings.glow = parseFloat(glowSlider.value);
  });
  micToggle.addEventListener('change', async () => {
    settings.micReactive = micToggle.checked;
    // when mic reactive is turned on but analyser not ready, initialize mic
    if (settings.micReactive && !settings.analyser) {
      try {
        await initMic();
      } catch (e) {
        console.error('Mic init failed', e);
      }
    }
  });
  windToggle.addEventListener('change', () => {
    settings.pointerWind = windToggle.checked;
  });
  driftToggle.addEventListener('change', () => {
    settings.drift = driftToggle.checked;
  });
  particleImagesInput.addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    settings.images = [];
    files.forEach(file => {
      const img = new Image();
      img.onload = () => settings.images.push(img);
      img.src = URL.createObjectURL(file);
    });
    initParticles();
  });
  backgroundImageInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const img = new Image();
      img.onload = () => {
        settings.background = img;
      };
      img.src = URL.createObjectURL(file);
    }
  });

  // Pointer wind handler
  let lastPointerX = null;
  canvas.addEventListener('pointerdown', (e) => {
    lastPointerX = e.clientX;
    // For pointer wind, track starting x
    if (settings.pointerWind) {
      // nothing else here
    }
    // Toggle drawing mode for path behaviour when user clicks on canvas
    if (settings.behavior === 'path') {
      if (!settings.drawing) {
        // start drawing: reset path and add first point
        settings.drawing = true;
        settings.pathPoints = [];
        settings.pathPoints.push({ x: e.clientX, y: e.clientY });
      } else {
        // stop drawing
        settings.drawing = false;
      }
    }
  });
  canvas.addEventListener('pointermove', (e) => {
    if (settings.pointerWind && lastPointerX !== null) {
      const dx = e.clientX - lastPointerX;
      // amplify wind and clamp to range; even stronger wind effect
      settings.windX = dx / width * 200;
      lastPointerX = e.clientX;
    }
    if (settings.behavior === 'path' && settings.drawing) {
      settings.pathPoints.push({ x: e.clientX, y: e.clientY });
    }
  });
  canvas.addEventListener('pointerup', () => {
    lastPointerX = null;
    settings.windX = 0;
    // no auto-stop for path drawing: toggled by pointerdown
  });
  clearPathBtn.addEventListener('click', () => {
    settings.pathPoints = [];
    settings.drawing = false;
  });

  // Hide/show panel
  hidePanelBtn.addEventListener('click', () => {
    panel.classList.add('hidden');
    showPanelBtn.classList.remove('hidden');
  });
  showPanelBtn.addEventListener('click', () => {
    panel.classList.remove('hidden');
    showPanelBtn.classList.add('hidden');
  });

  // Randomize
  randomizeBtn.addEventListener('click', () => {
    // random colors
    [c1,c2,c3,c4].forEach((input, idx) => {
      const randColor = '#' + Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0');
      input.value = randColor;
      settings.colors[idx] = randColor;
    });
    // random shape
    const shapes = ['circle','square','line','image','bars'];
    settings.shape = shapes[Math.floor(Math.random()*shapes.length)];
    shapeSelect.value = settings.shape;
    // random behaviour including new behaviours
    const behaviors = ['random','fromCenter','fromBottom','fromTop','fromLeft','fromRight','spiral','path','galaxy'];
    settings.behavior = behaviors[Math.floor(Math.random()*behaviors.length)];
    behaviorSelect.value = settings.behavior;
    // show/hide image upload and path controls based on new selections
    imageUploadRow.classList.toggle('hidden', settings.shape !== 'image');
    pathControls.classList.toggle('hidden', settings.behavior !== 'path');
    // random toggles
    settings.pointerWind = Math.random() < 0.5;
    windToggle.checked = settings.pointerWind;
    settings.drift = Math.random() < 0.5;
    driftToggle.checked = settings.drift;
    // random counts and sizes
    settings.count = Math.floor(Math.random()*400)+100;
    countSlider.value = settings.count;
    settings.size = Math.random()*20+5;
    sizeSlider.value = settings.size;
    // random width/height/glow
    settings.widthFactor = Math.random()*2+0.5;
    widthSlider.value = settings.widthFactor;
    settings.heightFactor = Math.random()*2+0.5;
    heightSlider.value = settings.heightFactor;
    settings.glow = Math.random()*2+0.5;
    glowSlider.value = settings.glow;
    // apply
    initParticles();
  });
  // Share settings
  shareBtn.addEventListener('click', () => {
    const params = new URLSearchParams();
    params.set('s', settings.shape);
    params.set('b', settings.behavior);
    settings.colors.forEach((c,i)=> params.set('c'+i, c.substring(1)));
    params.set('n', settings.count);
    params.set('sz', settings.size.toFixed(2));
    params.set('sp', settings.speed.toFixed(2));
    params.set('tu', settings.turb.toFixed(2));
    params.set('mi', settings.micReactive ? '1':'0');
    params.set('pw', settings.pointerWind ? '1':'0');
    params.set('dr', settings.drift ? '1':'0');
    params.set('wf', settings.widthFactor.toFixed(2));
    params.set('hf', settings.heightFactor.toFixed(2));
    params.set('gl', settings.glow.toFixed(2));
    const url = window.location.origin + window.location.pathname + '?' + params.toString();
    navigator.clipboard.writeText(url).then(() => alert('Share link copied!'));
  });

  // Generate embed code
  embedBtn.addEventListener('click', () => {
    // Build query params like share
    const params = new URLSearchParams();
    params.set('s', settings.shape);
    params.set('b', settings.behavior);
    settings.colors.forEach((c,i)=> params.set('c'+i, c.substring(1)));
    params.set('n', settings.count);
    params.set('sz', settings.size.toFixed(2));
    params.set('sp', settings.speed.toFixed(2));
    params.set('tu', settings.turb.toFixed(2));
    params.set('mi', settings.micReactive ? '1':'0');
    params.set('pw', settings.pointerWind ? '1':'0');
    params.set('dr', settings.drift ? '1':'0');
    params.set('wf', settings.widthFactor.toFixed(2));
    params.set('hf', settings.heightFactor.toFixed(2));
    params.set('gl', settings.glow.toFixed(2));
const url = window.location.origin + window.locat=1n.=1 + '?embed=1&' + params.toString();;
    
    const embedCode = `<iframe src="${url}" style="width:100%;height:100%;border:0;"></iframe>`;
    navigator.clipboard.writeText(embedCode).then(() => alert('Embed code copied!'));
  });

  // Restore from URL hash
  function loadFromParams() {
    const p = new URLSearchParams(window.location.search);
      if (p.has('embed')) {
    panel.classList.add('hidden');
  hidePanelBtn.classList.add('hidden');
  showPanelBtn
  showPanelBtn.classList.add('hidden//  
    if (p.has('s')) { settings.shape = p.get('s'); shapeSelect.value = settings.shape; }
    if (p.has('b')) { settings.behavior = p.get('b'); behaviorSelect.value = settings.behavior; }
    for (let i=0; i<4; i++) {
      if (p.has('c'+i)) {
        const col = '#' + p.get('c'+i);
        settings.colors[i] = col;
        [c1,c2,c3,c4][i].value = col;
      }
    }
    if (p.has('n')) { settings.count = parseInt(p.get('n'),10); countSlider.value = settings.count; }
    if (p.has('sz')) { settings.size = parseFloat(p.get('sz')); sizeSlider.value = settings.size; }
    if (p.has('sp')) { settings.speed = parseFloat(p.get('sp')); speedSlider.value = settings.speed; }
    if (p.has('tu')) { settings.turb = parseFloat(p.get('tu')); turbSlider.value = settings.turb; }
    if (p.has('mi')) { settings.micReactive = p.get('mi') === '1'; micToggle.checked = settings.micReactive; }
    if (p.has('pw')) { settings.pointerWind = p.get('pw') === '1'; windToggle.checked = settings.pointerWind; }
    if (p.has('dr')) { settings.drift = p.get('dr') === '1'; driftToggle.checked = settings.drift; }
    if (p.has('wf')) { settings.widthFactor = parseFloat(p.get('wf')); widthSlider.value = settings.widthFactor; }
    if (p.has('hf')) { settings.heightFactor = parseFloat(p.get('hf')); heightSlider.value = settings.heightFactor; }
    if (p.has('gl')) { settings.glow = parseFloat(p.get('gl')); glowSlider.value = settings.glow; }

    // update visibility for image upload and path controls after loading
    imageUploadRow.classList.toggle('hidden', settings.shape !== 'image');
    pathControls.classList.toggle('hidden', settings.behavior !== 'path');
  }

  // Initialization
  loadFromParams();
  // initMic();
  initParticles();
  animate();
  </script>
</body>
</html>
